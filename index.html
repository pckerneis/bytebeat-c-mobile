<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bytebeat C Mobile</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
            max-width: 500px;
            margin: 0 auto;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            gap: 4px;
            padding: 5px 10px;
            background: #222;
            border-bottom: 1px solid #333;
        }

        .toolbar button {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 12px;
            color: #e0e0e0;
            cursor: pointer;
        }

        .toolbar button:active {
            background: #444;
        }

        .toolbar button:disabled {
            opacity: 0.4;
            cursor: default;
        }

        .toolbar .spacer {
            flex: 1;
        }

        /* Expression Panel */
        .expression-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 80px;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }

        .expression-display {
            flex: 1;
            background: #0d0d0d;
            border: 1px solid #333;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 18px;
            overflow-y: auto;
            overflow-x: hidden;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.4;
        }

        .expression-display .cursor {
            animation: blink-cursor 1s infinite;
        }

        .expression-display .cursor-end {
            animation: blink-end 1s infinite;
        }

        @keyframes blink-cursor {
            0%, 50% { background: #e0e0e0; color: #0d0d0d; }
            51%, 100% { background: transparent; color: #e0e0e0; }
        }

        @keyframes blink-end {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Keyboard Panel */
        .keyboard {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
        }

        .keyboard .key {
            border: none;
            box-shadow: inset 2px 2px 0px 0px #ffffff12, inset -2px -2px 0px 0px #000000d9;
        }

        .key {
            position: relative;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 0;
            padding: 12px 4px;
            font-size: 18px;
            font-family: 'Consolas', 'Monaco', monospace;
            color: #e0e0e0;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 48px;
        }

        .key-hint {
            position: absolute;
            font-size: 11px;
            color: #888;
            line-height: 1;
        }

        .key-hint.shift {
            top: 6px;
            left: 8px;
            color: rgb(119, 119, 185);
        }

        .key-hint.abc {
            top: 6px;
            right: 8px;
            color: rgb(93, 136, 93);
        }

        .key:active {
            background: #444;
        }

        .key.shift {
            background: rgb(60, 60, 143);
        }

        .key.shift:active, .key.shift.active {
            background: rgb(81, 81, 165);
        }

        .key.abc {
            background: rgb(43, 71, 53);
        }

        .key.abc:active, .key.abc.active {
            background: rgb(60, 108, 77);
        }

        .key.toggle {
            position: relative;
        }

        .key.toggle::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00000098;
            position: absolute;
            top: 6px;
            left: 6px;
        }

        .key.toggle.active::before {
            background: #ffffff;
            mix-blend-mode: overlay;
        }

        .key.action {
            background: #3a1e1e;
            border-color: #5a2a2a;
        }

        .key.action:active {
            background: #5a2a2a;
        }

        .key.play {
            background: #1e3a1e;
            border-color: #2a5a2a;
        }

        .key.play:active, .key.play.active {
            background: #2a5a2a;
            border-color: #3a7a3a;
        }

        .key.live {
            background: #3a2a1e;
            border-color: #5a3a2a;
        }

        .key.live:active, .key.live.active {
            background: #5a4a2a;
            border-color: #7a6a3a;
        }

        .key.nav {
            background: #2a2a3a;
            border-color: #3a3a5a;
        }

        .key.nav:active {
            background: #3a3a5a;
        }

        /* Library Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 8px;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 15px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 18px;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
        }

        .modal-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #library-list {
            overflow-y: auto;
            flex: 1;
        }

        .library-item {
            background: #2a2a2a;
            padding: 10px;
            cursor: pointer;
            margin-bottom: 1px;
        }

        .library-item:hover {
            background: #333;
            border-color: #555;
        }

        .library-item:active {
            background: #3a3a3a;
        }

        .library-item-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #4a9eff;
        }

        .library-item-info {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }

        .library-item-code {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            color: #aaa;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .library-tabs {
            display: flex;
            margin-bottom: 10px;
        }

        .library-tab {
            background: #2a2a2a;
            padding: 8px 12px;
            font-size: 14px;
            color: #e0e0e0;
            cursor: pointer;
            flex: 1;
        }

        .library-tab.active {
            background: #243850;
            box-shadow: inset 2px 2px 0px 0px #000000a6, inset -2px -2px 0px 0px #313131d9;
            border: none;
        }

        .saved-item-delete {
            background: #5a2a2a;
            border: 1px solid #7a3a3a;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            color: #e0e0e0;
            cursor: pointer;
            float: right;
        }

        .saved-item-delete:active {
            background: #7a3a3a;
        }

            </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <button id="undo-btn" disabled>Undo</button>
            <button id="redo-btn" disabled>Redo</button>
            <button id="library-btn">Library</button>
            <span class="spacer"></span>
            <button id="save-btn">Save</button>
            <button id="copy-btn">Copy</button>
            <button id="paste-btn">Paste</button>
        </div>
        <div class="expression-panel">
            <div class="status-bar">
                <span id="sr-display">SR: 8000</span>
                <span id="mode-display"></span>
            </div>
            <div class="expression-display" id="expr-display"><span id="expr-before"></span><span id="expr-cursor"></span><span id="expr-after"></span></div>
        </div>

        <div class="keyboard-panel">
            <div class="keyboard" id="keyboard"></div>
        </div>
    </div>

    <!-- Library Modal -->
    <div class="modal" id="library-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Sound Library</h2>
                <button class="modal-close" id="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="library-tabs">
                    <button class="library-tab active" id="tab-presets">Presets</button>
                    <button class="library-tab" id="tab-saved">Saved</button>
                </div>
                <div id="library-list"></div>
            </div>
        </div>
    </div>

    <script>
        // Worklet code as string
        const workletCode = `
class BytebeatProcessor extends AudioWorkletProcessor {
    constructor() {
        super();
        this.t = 0;
        this.rpn = [];
        this.jsFunc = null;
        this.mode = 'C';
        this.playing = false;
        this.port.onmessage = (e) => {
            if (e.data.type === 'setRPN') {
                this.rpn = e.data.rpn;
                this.jsFunc = null;
                this.mode = e.data.mode || 'C';
                if (!e.data.keepTime) this.t = 0;
            } else if (e.data.type === 'setJS') {
                try { this.jsFunc = new Function('t', 'const {abs,acos,acosh,asin,asinh,atan,atan2,atanh,cbrt,ceil,clz32,cos,cosh,exp,expm1,floor,fround,hypot,imul,log,log1p,log2,log10,max,min,pow,random,round,sign,sin,sinh,sqrt,tan,tanh,trunc,E,LN2,LN10,LOG2E,LOG10E,PI,SQRT1_2,SQRT2}=Math;return ' + e.data.expr); }
                catch(err) { this.jsFunc = null; }
                this.rpn = [];
                this.mode = e.data.mode;
                if (!e.data.keepTime) this.t = 0;
            } else if (e.data.type === 'play') {
                this.playing = true;
            } else if (e.data.type === 'stop') {
                this.playing = false;
            } else if (e.data.type === 'reset') {
                this.t = 0;
            }
        };
    }

    // Typed value helpers: {v: value, i: isInteger}
    I(n) { return {v: Math.trunc(n), i: true}; }
    F(n) { return {v: n, i: false}; }
    pop(stack) { const x = stack.pop(); return x || {v: 0, i: true}; }
    val(x) { return x.v; }

    evalRPN(t) {
        if (this.rpn.length === 0) return 0;
        const stack = [];
        const vars = {}; // Variables reset on each sample
        
        for (let i = 0; i < this.rpn.length; i++) {
            const token = this.rpn[i];
            
            // Typed number from parser: {v, i}
            if (typeof token === 'object' && 'v' in token) {
                stack.push(token);
            } else if (token === 't') {
                stack.push(this.I(t));
            } else if (typeof token === 'string' && token.startsWith('VAR:')) {
                // Variable reference
                const varName = token.substring(4);
                const value = vars[varName];
                stack.push(value || this.I(0));
            } else if (typeof token === 'string' && token !== '=' && i + 1 < this.rpn.length && this.rpn[i + 1] === '=') {
                // This is a variable name followed by '=' - skip it, will be handled by '=' case
                continue;
            } else if (typeof token === 'string' && token === '=') {
                // Variable assignment: previous token is variable name, pop value from stack
                const varName = this.rpn[i - 1];
                const value = this.pop(stack);
                vars[varName] = value;
                stack.push(value);
            } else {
                let a, b, c, av, bv, cv, bothInt;
                switch (token) {
                    // Arithmetic - type depends on operands
                    case '+':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        stack.push(bothInt ? this.I(a.v + b.v) : this.F(a.v + b.v));
                        break;
                    case '-':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        stack.push(bothInt ? this.I(a.v - b.v) : this.F(a.v - b.v));
                        break;
                    case '*':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        stack.push(bothInt ? this.I(a.v * b.v) : this.F(a.v * b.v));
                        break;
                    case '/':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        if (b.v === 0) { stack.push(this.I(0)); }
                        else if (bothInt) { stack.push(this.I(Math.trunc(a.v / b.v))); }
                        else { stack.push(this.F(a.v / b.v)); }
                        break;
                    case '%':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        if (b.v === 0) { stack.push(this.I(0)); }
                        else if (bothInt) { stack.push(this.I(a.v % b.v)); }
                        else { stack.push(this.F(a.v - Math.trunc(a.v / b.v) * b.v)); }
                        break;
                    // Bitwise - always integer
                    case '&': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v & b.v)); break;
                    case '|': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v | b.v)); break;
                    case '^': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v ^ b.v)); break;
                    case '~': a = this.pop(stack); stack.push(this.I(~a.v)); break;
                    case '<<': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v << b.v)); break;
                    case '>>': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v >> b.v)); break;
                    // Comparison - always integer (0 or 1)
                    case '<': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v < b.v ? 1 : 0)); break;
                    case '>': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v > b.v ? 1 : 0)); break;
                    case '<=': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v <= b.v ? 1 : 0)); break;
                    case '>=': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v >= b.v ? 1 : 0)); break;
                    case '==': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v === b.v ? 1 : 0)); break;
                    case '!=': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v !== b.v ? 1 : 0)); break;
                    // Ternary - preserves type of selected branch
                    case '?:':
                        c = this.pop(stack); b = this.pop(stack); a = this.pop(stack);
                        stack.push(a.v ? b : c);
                        break;
                    // Trig - always float
                    case 'sin': a = this.pop(stack); stack.push(this.F(Math.sin(a.v))); break;
                    case 'cos': a = this.pop(stack); stack.push(this.F(Math.cos(a.v))); break;
                    case 'tan': a = this.pop(stack); stack.push(this.F(Math.tan(a.v))); break;
                    case 'asin': a = this.pop(stack); stack.push(this.F(Math.asin(a.v))); break;
                    case 'acos': a = this.pop(stack); stack.push(this.F(Math.acos(a.v))); break;
                    case 'atan': a = this.pop(stack); stack.push(this.F(Math.atan(a.v))); break;
                    // Hyperbolic - always float
                    case 'sinh': a = this.pop(stack); stack.push(this.F(Math.sinh(a.v))); break;
                    case 'cosh': a = this.pop(stack); stack.push(this.F(Math.cosh(a.v))); break;
                    case 'tanh': a = this.pop(stack); stack.push(this.F(Math.tanh(a.v))); break;
                    // Roots & powers - always float
                    case 'sqrt': a = this.pop(stack); stack.push(this.F(Math.sqrt(a.v))); break;
                    case 'cbrt': a = this.pop(stack); stack.push(this.F(Math.cbrt(a.v))); break;
                    case 'pow': b = this.pop(stack); a = this.pop(stack); stack.push(this.F(Math.pow(a.v, b.v))); break;
                    case 'exp': a = this.pop(stack); stack.push(this.F(Math.exp(a.v))); break;
                    // Logs - always float
                    case 'log': a = this.pop(stack); stack.push(this.F(Math.log(a.v))); break;
                    case 'log10': a = this.pop(stack); stack.push(this.F(Math.log10(a.v))); break;
                    // Rounding - returns integer
                    case 'floor': a = this.pop(stack); stack.push(this.I(Math.floor(a.v))); break;
                    case 'ceil': a = this.pop(stack); stack.push(this.I(Math.ceil(a.v))); break;
                    case 'round': a = this.pop(stack); stack.push(this.I(Math.round(a.v))); break;
                    // Type conversion
                    case 'int': a = this.pop(stack); stack.push(this.I(a.v)); break;
                    case 'float': a = this.pop(stack); stack.push(this.F(a.v)); break;
                    // Misc - abs preserves type, fabs returns float
                    case 'abs': a = this.pop(stack); stack.push(a.i ? this.I(Math.abs(a.v)) : this.F(Math.abs(a.v))); break;
                    case 'fabs': a = this.pop(stack); stack.push(this.F(Math.abs(a.v))); break;
                    case 'min':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        stack.push(bothInt ? this.I(Math.min(a.v, b.v)) : this.F(Math.min(a.v, b.v)));
                        break;
                    case 'max':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        stack.push(bothInt ? this.I(Math.max(a.v, b.v)) : this.F(Math.max(a.v, b.v)));
                        break;
                    case 'fmod':
                        b = this.pop(stack); a = this.pop(stack);
                        stack.push(this.F(b.v !== 0 ? a.v - Math.trunc(a.v / b.v) * b.v : 0));
                        break;
                    case 'modf': a = this.pop(stack); stack.push(this.F(a.v - Math.trunc(a.v))); break;
                    // Constants - float
                    case 'PI': stack.push(this.F(Math.PI)); break;
                    case 'E': stack.push(this.F(Math.E)); break;
                    // Comma operator - pop left and right, return right
                    case ',':
                        b = this.pop(stack); // right operand
                        a = this.pop(stack); // left operand (discarded)
                        stack.push(b);
                        break;
                    default:
                        break;
                }
            }
        }
        const result = this.pop(stack);
        return result.v & 255;
    }

    process(inputs, outputs) {
        const output = outputs[0];
        if (!this.playing || output.length === 0) {
            return true;
        }
        const channel = output[0];
        for (let i = 0; i < channel.length; i++) {
            let raw;
            if (this.jsFunc) {
                try { raw = this.jsFunc(this.t); } catch(e) { raw = 0; }
            } else {
                raw = this.evalRPN(this.t);
            }
            switch (this.mode) {
                case 'JS-float':
                    channel[i] = Math.max(-1, Math.min(1, raw || 0));
                    break;
                case 'JS-int8':
                    channel[i] = Math.max(-1, Math.min(1, (raw || 0) / 128));
                    break;
                case 'JS-uint8':
                    channel[i] = (((raw || 0) & 255) - 128) / 128;
                    break;
                default:
                    channel[i] = (raw - 128) / 128;
                    break;
            }
            this.t++;
        }
        return true;
    }
}

registerProcessor('bytebeat-processor', BytebeatProcessor);
`;

        // Predefined sound library
        const presetLibrary = [
            { title: '(empty)', author: '-', sampleRate: 8000, code: '' },

            // Source: https://www.youtube.com/watch?v=GtQdIYUtAHg
            { title: 'untitled', author: 'viznut', sampleRate: 8000, code: 't*((t>>12|t>>8)&63&t>>4)' },
            { title: 'untitled', author: 'tejeez', sampleRate: 8000, code: 't*((t>>5|t>>8))>>(t>>16)' },
            { title: 'untitled', author: 'visy', sampleRate: 8000, code: 't*((t>>9|t>>13)&25&t>>6)' },
            { title: 'untitled', author: 'tejeez', sampleRate: 8000, code: 't*((t>>11&t>>8&123&t>>3)' },
            { title: 'untitled', author: 'visy', sampleRate: 8000, code: '(t*(t>>8*(t>>15|t>>8)&(20|(t>>19)*5>>t|t>>3))' },
            { title: 'untitled', author: 'tejeez', sampleRate: 8000, code: '((-t&4095)*(255&t*(t&t>>13))>>12)+(127&t*(234&t>>8&t>>3)>>(3&t>>14))' },
            { title: 'Space Invaders vs Pong', author: 'visy', sampleRate: 8000, code: 't*(t>>((t>>9|t>>8))&63&t>>4)' },

            // Source: https://www.youtube.com/watch?v=qlrs2Vorw2Y
            { title: 'untitled', author: 'viznut', sampleRate: 8000, code: '(t>>6|t|t>>(t>>16))*10+((t>>11)&7)' },
            { title: 'untitled', author: 'pyryp', sampleRate: 8000, code: 'v=(v>>1)+(v>>4)+t*(((t>>16)|(t>>6))&(69&(t>>9)))' },
            { title: 'untitled', author: 'red-', sampleRate: 8000, code: '(t|(t>>9|t>>7))*t&(t>>11|t>>9)' },
            { title: 'untitled', author: 'miiro', sampleRate: 8000, code: 't*5&(t>>7)|t*3&(t*4>>10)' },
            { title: 'untitled', author: 'viznut', sampleRate: 8000, code: '(t>>7|t|t>>6)*10+4*(t&t>>13|t>>6)' },
            { title: 'untitled', author: 'shurk', sampleRate: 8000, code: '((t&4096)?((t*(t^t%255)|(t>>4))>>1):(t>>3)|((t&8192)?t<<2:t))' },
            { title: 'Lost in Space', author: 'xpansive', sampleRate: 8000, code: '((t*(t>>8|t>>9)&46&t>>8))^(t&t>>13|t>>6)' },

            // Source: https://www.youtube.com/watch?v=V4GfkFbDojc
            { title: 'Crazy Grooby Beats', author: 'Gabriel Miceli', sampleRate: 32000, code: 'a=t-2048,((t&t>>6)&(t*(t>>((t&65535)>>12))))+((t*3/4&t>>12)&127)+(t*(a>>7&a>>8&a>>9&16)>>t/64)' },
            { title: 'Noise Maker', author: 'Gabriel Miceli', sampleRate: 11025, code: 'i=t&8191,(((t*((t>>9^((t>>9)-1)^1)%13)&255)/2)+((((t>>3|t<<(t>>12&2))*(i<4096)+(t>>4|t*(t^t+t/256))*(i>4095)))&255)/2)*(2+(t>>16))' },
            { title: 'Crude Sinewave Dubstep', author: 'Gabriel Miceli', sampleRate: 44100, code: 'd=(t*(t&t>>12)*8/11025)|0,((d&16)/8-1)*(d*(d^15)+d+127)' },
            { title: 'The Rhythm', author: 'Gabriel Miceli', sampleRate: 8000, code: 'a=t-256,((44*(t/256-28|3)|t*8&t>>11&t>>5|t*(a>>3&a>>4&a>>5&64)>>t/16)/2&127)+(((t^t+t/256)&255)/(5-(t>>17&3))/2&127)' },
            { title: 'Crazy Grooby Beats 2', author: 'Gabriel Miceli', sampleRate: 8000, code: 'd=t>>12&1,h=(t>>9)+4,(t*t*(t&255)*d/156+(t*(t^15)+t)*((h|t/2048+1&127)-h)/64&127-d*((t>>5&127)*2/3+32))' },
            { title: 'Techno', author: 'Gabriel Miceli', sampleRate: 11025, code: '(t*(((t/10|0)^(t/10|0)-1280)%11)/2&127)+(t*(((t/640|0)^(t/640|0)-2)%13)/2&127)' },
            { title: 'New Sawtooth Music', author: 'Gabriel Miceli', sampleRate: 8000, code: 't*((t-2296&t)>>11)' },
            { title: 'New Sawtooth Music (again) Remix', author: 'Gabriel Miceli', sampleRate: 8000, code: 'j=(t-41024&t+1024)>>11&255,k=t&16383,(t*(j&255)/2&127)+((100000/(t&4095))/4&63)+((int(k/(k>>7)-136)/8)&((32*(1+(j>7))-1)))' },
            { title: 'Deep Tones', author: 'Gabriel Miceli', sampleRate: 8000, code: 't*(t*287/256&t>>11&31)' },
            { title: 'Shapeshifter Tune', author: 'Gabriel Miceli', sampleRate: 8000, code: 'y=t*(t>>10&42),y*2|y+t/64' },
            { title: 'Now this actually sounds pretty cool.', author: 'Gabriel Miceli', sampleRate: 8000, code: 'd=t*465/(43+6*(t>>15&3^1)),((d/4&t>>6)+d/2&127)+(d/6&127)' },
            { title: 'Song by Gabriel Miceli', author: 'Gabriel Miceli', sampleRate: 8000, code: '(-1-t|t+t/256)-(-(t-(t>>8))|t+(t>>8))' },
            { title: 'Song by Gabriel Miceli #2', author: 'Gabriel Miceli', sampleRate: 8000, code: '(t&t+t/256)-t*(t>>15)&64' },
            { title: 'Alien Disco', author: 'unknown', sampleRate: 32000, code: 'd=t>>15&t>>11,e=t>>6,t*(d&1&e)+t*(d&4&e)/2+t*(d&8&e)*3/4+t*(1-((d&(t>>13)+1)&1))+t*(t+t^15*t)*(t>>9&t>>11&4)/1024' },
            { title: 'Moon Scanner Generalization', author: 'viznut', sampleRate: 8000, code: '((t>>5&t)-(t>>5)+(t>>5&t))+(t*((t>>14)&14))' },
            { title: 'Another attempt at melody construction', author: 'viznut', sampleRate: 8000, code: '(t*((3+(1^t>>10&5))*(5+(3&t>>14))))>>(t>>8&3)' },
            { title: 'Song by tejeez', author: 'tejeez', sampleRate: 8000, code: '(~t>>2)*((127&t*(7&t>>10))<(245&t*(2+(5&t>>14))))' },
            { title: 'Song by skurk', author: 'skurk', sampleRate: 8000, code: 't*(t>>((t&4096)?((t*t)/4096):(t/4096)))|(t<<(t/256))|(t>>4)' },
            
            // pck404's creations
            { title: 'deadbeef', author: 'pck404', sampleRate: 8000, code: 't*(0xdeadbeef>>(t>>11)&15)/2|t>>3|t>>(t>>10)' },
            { title: 'Final Fantasy Prelude', author: 'pck404', sampleRate: 8000, code: `M=29728,M2=60532,m=29472,M7=46912,
rt=0x53204747,
ch=[M,m,M,m,M2,M2,M7,M7],
m1=[
0x99667777,0x77777777,0x99667777,0x777777b9,
0x44224444,0x66997666,0xa79a7777,0x99cca999
],
m2=[
0xcc99bbbb,0xbbbbbbbb,0xcc99bbbb,0xbbbbbbec,
0x77667777,0x66667999,0x77779acc,0x9999acee
],
T=t>>10,
S=T>>2,
A=T=>(
  a=T>>5&7,
  b=abs(((T+16)&31)-16),
  ((t*2**(1+(b>>2)+((rt>>a%8*4&15)+(ch[a]>>(b&3)*4&15))/12))&128)*(1.5-(t/1024)%1)
),
B=(p,o)=>((t*2**(o+(p[S>>3&7]>>S%16*4&15)/12))&127)*0.4,

A(T)/2
+A(T-3)/6
+A(T-6)/8
+(B(m1,2)+B(m2,3)*0.5+((t*2**(1+(0x53204747>>((S>>3)&7)*4&15)/12))&128)*0.2)*(S>63)`}
        ];

        // State - load expression from localStorage
        let expression = localStorage.getItem('bytebeat-expr') || '';
        let cursorPos = expression.length;
        let undoStack = [];
        let redoStack = [];
        let currentSampleRate = 8000;
        let abcMode = false;
        let shiftActive = false;
        let playBtnEl = null;
        let abcBtnEl = null;
        let isPlaying = false;
        let liveMode = false;
        let audioCtx = null;
        let workletNode = null;
        let gainNode = null;
        let currentMode = 'C';
        let volume = 1.0;
        let shiftLocked = false;
        let shiftLongPressTimer = null;
        const SHIFT_LONG_PRESS_MS = 400;
        let srInputMode = false;
        let srInputBuffer = '';
        let modeSelectMode = false;
        const modes = ['C', 'JS-uint8', 'JS-int8', 'JS-float'];
        let savedSongs = JSON.parse(localStorage.getItem('bytebeat-saved') || '[]');
        let currentLibraryTab = 'presets';

        // Key repeat state
        let keyRepeatTimer = null;
        let keyRepeatInterval = null;
        let currentRepeatAction = null;
        const KEY_REPEAT_DELAY = 500; // ms before repeat starts
        const KEY_REPEAT_RATE = 50;   // ms between repeats

        // DOM elements
        const exprBefore = document.getElementById('expr-before');
        const exprCursor = document.getElementById('expr-cursor');
        const exprAfter = document.getElementById('expr-after');
        const srDisplay = document.getElementById('sr-display');
        const modeDisplay = document.getElementById('mode-display');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const copyBtn = document.getElementById('copy-btn');
        const pasteBtn = document.getElementById('paste-btn');
        const libraryBtn = document.getElementById('library-btn');
        const saveBtn = document.getElementById('save-btn');
        const libraryModal = document.getElementById('library-modal');
        const modalClose = document.getElementById('modal-close');
        const libraryList = document.getElementById('library-list');
        const tabPresets = document.getElementById('tab-presets');
        const tabSaved = document.getElementById('tab-saved');

        // Save expression to localStorage
        function saveExpression() {
            localStorage.setItem('bytebeat-expr', expression);
        }

        // Save state for undo
        function saveState() {
            undoStack.push({ expression, cursorPos });
            redoStack = [];
            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length > 0) {
                redoStack.push({ expression, cursorPos });
                const state = undoStack.pop();
                expression = state.expression;
                cursorPos = state.cursorPos;
                updateDisplay();
                updateUndoRedoButtons();
                liveUpdate();
                saveExpression();
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                undoStack.push({ expression, cursorPos });
                const state = redoStack.pop();
                expression = state.expression;
                cursorPos = state.cursorPos;
                updateDisplay();
                updateUndoRedoButtons();
                liveUpdate();
                saveExpression();
            }
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
        }

        // Update display
        function updateDisplay() {
            if (srInputMode) {
                exprBefore.textContent = 'SR: ' + srInputBuffer;
                exprCursor.textContent = '_';
                exprCursor.className = 'cursor-end';
                exprAfter.textContent = '\n\nEnter sample rate (100-48000)\n\u25B8 to confirm';
            } else if (modeSelectMode) {
                exprBefore.textContent = '';
                exprCursor.textContent = '';
                exprCursor.className = '';
                exprAfter.textContent = '\u2190 ' + currentMode + ' \u2192\n\n\u25B8 to confirm';
            } else {
                exprBefore.textContent = expression.slice(0, cursorPos);
                if (cursorPos >= expression.length) {
                    exprCursor.textContent = '_';
                    exprCursor.className = 'cursor-end';
                    exprAfter.textContent = '';
                } else {
                    exprCursor.textContent = expression[cursorPos];
                    exprCursor.className = 'cursor';
                    exprAfter.textContent = expression.slice(cursorPos + 1);
                }
            }
            srDisplay.textContent = `${currentMode} SR:${currentSampleRate} V:${volume.toFixed(1)}`;
            modeDisplay.textContent = abcMode ? 'ABC' : '';
        }

        // Live update - send new expression to worklet without resetting t
        function liveUpdate() {
            if (liveMode && isPlaying && workletNode) {
                sendExpression(true);
            }
        }

        // Insert character at cursor
        function insertChar(char) {
            saveState();
            expression = expression.slice(0, cursorPos) + char + expression.slice(cursorPos);
            cursorPos += char.length;
            updateDisplay();
            liveUpdate();
            saveExpression();
        }

        // Delete character before cursor
        function deleteChar() {
            if (cursorPos > 0) {
                saveState();
                expression = expression.slice(0, cursorPos - 1) + expression.slice(cursorPos);
                cursorPos--;
                updateDisplay();
                liveUpdate();
                saveExpression();
            }
        }

        // Move cursor
        function moveCursor(dir) {
            cursorPos = Math.max(0, Math.min(expression.length, cursorPos + dir));
            updateDisplay();
        }

        // Library functions
        function openLibrary() {
            libraryModal.classList.add('active');
            renderLibrary();
        }

        function closeLibrary() {
            libraryModal.classList.remove('active');
        }

        function switchLibraryTab(tab) {
            currentLibraryTab = tab;
            tabPresets.classList.toggle('active', tab === 'presets');
            tabSaved.classList.toggle('active', tab === 'saved');
            renderLibrary();
        }

        function renderLibrary() {
            libraryList.innerHTML = '';
            const items = currentLibraryTab === 'presets' ? presetLibrary : savedSongs;
            
            items.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'library-item';
                
                const title = document.createElement('div');
                title.className = 'library-item-title';
                title.textContent = item.title;
                
                const info = document.createElement('div');
                info.className = 'library-item-info';
                info.textContent = `${item.author || 'Unknown'} â€¢ ${item.sampleRate}Hz`;
                
                const code = document.createElement('div');
                code.className = 'library-item-code';
                code.textContent = item.code;
                
                div.appendChild(title);
                div.appendChild(info);
                div.appendChild(code);
                
                if (currentLibraryTab === 'saved') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'saved-item-delete';
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteSavedSong(index);
                    };
                    title.appendChild(deleteBtn);
                }
                
                div.onclick = () => loadSong(item);
                libraryList.appendChild(div);
            });
        }

        function loadSong(song) {
            saveState();
            expression = song.code;
            cursorPos = expression.length;
            
            // Set sample rate
            currentSampleRate = song.sampleRate;
            
            updateDisplay();
            saveExpression();
            closeLibrary();
            
            // If playing, restart with new expression
            if (isPlaying) {
                stopAudio();
                startAudio();
            }
        }

        function saveCurrentSong() {
            if (!expression.trim()) {
                alert('Cannot save empty expression');
                return;
            }
            
            const title = prompt('Enter a title for this song:');
            if (!title) return;
            
            const author = prompt('Enter author name (optional):') || 'User';
            
            const song = {
                title: title,
                author: author,
                sampleRate: currentSampleRate,
                code: expression
            };
            
            savedSongs.push(song);
            localStorage.setItem('bytebeat-saved', JSON.stringify(savedSongs));
            alert('Song saved!');
        }

        function deleteSavedSong(index) {
            if (confirm('Delete this saved song?')) {
                savedSongs.splice(index, 1);
                localStorage.setItem('bytebeat-saved', JSON.stringify(savedSongs));
                renderLibrary();
            }
        }

        // C expression tokenizer
        function tokenize(expr) {
            const tokens = [];
            let i = 0;
            while (i < expr.length) {
                const c = expr[i];

                // Skip whitespace
                if (/\s/.test(c)) {
                    i++;
                    continue;
                }

                // Numbers (decimal, hex, binary) - track if integer or float
                if (/[0-9]/.test(c) || (c === '0' && (expr[i+1] === 'x' || expr[i+1] === 'b'))) {
                    let num = '';
                    let isInt = true;
                    if (c === '0' && expr[i+1] === 'x') {
                        // Hex - always integer
                        i += 2;
                        while (i < expr.length && /[0-9a-fA-F]/.test(expr[i])) {
                            num += expr[i++];
                        }
                        tokens.push({ type: 'num', value: parseInt(num, 16) || 0, isInt: true });
                    } else if (c === '0' && expr[i+1] === 'b') {
                        // Binary - always integer
                        i += 2;
                        while (i < expr.length && /[01]/.test(expr[i])) {
                            num += expr[i++];
                        }
                        tokens.push({ type: 'num', value: parseInt(num, 2) || 0, isInt: true });
                    } else {
                        // Decimal - integer unless contains '.'
                        while (i < expr.length && /[0-9.]/.test(expr[i])) {
                            if (expr[i] === '.') isInt = false;
                            num += expr[i++];
                        }
                        tokens.push({ type: 'num', value: parseFloat(num) || 0, isInt: isInt });
                    }
                    continue;
                }

                // Identifiers (t, variables, functions)
                if (/[a-zA-Z_]/.test(c)) {
                    let id = '';
                    while (i < expr.length && /[a-zA-Z_0-9]/.test(expr[i])) {
                        id += expr[i++];
                    }
                    if (id === 't') {
                        tokens.push({ type: 't' });
                    } else {
                        // Check if it's followed by '=' (variable assignment) or '(' (function)
                        let j = i;
                        while (j < expr.length && /\s/.test(expr[j])) j++;
                        if (j < expr.length && expr[j] === '=') {
                            tokens.push({ type: 'var', value: id });
                        } else if (j < expr.length && expr[j] === '(') {
                            tokens.push({ type: 'func', value: id });
                        } else {
                            // Variable reference
                            tokens.push({ type: 'var', value: id });
                        }
                    }
                    continue;
                }

                // Two-char operators
                const two = expr.slice(i, i+2);
                if (['<<', '>>', '<=', '>=', '==', '!='].includes(two)) {
                    tokens.push({ type: 'op', value: two });
                    i += 2;
                    continue;
                }

                // Single-char operators and parens
                if ('+-*/%&|^~<>?:(),='.includes(c)) {
                    if (c === '=') {
                        tokens.push({ type: '=', value: c });
                    } else {
                        tokens.push({ type: c === '(' || c === ')' ? c : (c === ',' ? ',' : 'op'), value: c });
                    }
                    i++;
                    continue;
                }

                // Unknown, skip
                i++;
            }
            return tokens;
        }

        // Shunting-yard algorithm for C expression to RPN
        function toRPN(expr) {
            const tokens = tokenize(expr);
            const output = [];
            const opStack = [];

            const precedence = {
                '?': 1, ':': 1,
                '|': 2,
                '^': 3,
                '&': 4,
                '==': 5, '!=': 5,
                '<': 6, '>': 6, '<=': 6, '>=': 6,
                '<<': 7, '>>': 7,
                '+': 8, '-': 8,
                '*': 9, '/': 9, '%': 9,
                '~': 10,
            };

            const rightAssoc = new Set(['?', ':']);

            let ternaryStack = []; // Track ternary operators

            for (let i = 0; i < tokens.length; i++) {
                const tok = tokens[i];

                if (tok.type === 'num') {
                    output.push(tok.value);
                } else if (tok.type === 't') {
                    output.push('t');
                } else if (tok.type === 'func') {
                    opStack.push(tok);
                } else if (tok.type === '(') {
                    opStack.push(tok);
                } else if (tok.type === ')') {
                    while (opStack.length && opStack[opStack.length - 1].type !== '(') {
                        const op = opStack.pop();
                        output.push(op.value);
                    }
                    if (opStack.length) opStack.pop(); // Remove '('
                    if (opStack.length && opStack[opStack.length - 1].type === 'func') {
                        output.push(opStack.pop().value);
                    }
                } else if (tok.type === ',') {
                    while (opStack.length && opStack[opStack.length - 1].type !== '(') {
                        output.push(opStack.pop().value);
                    }
                } else if (tok.type === 'op') {
                    const op = tok.value;

                    // Handle ternary operator
                    if (op === '?') {
                        ternaryStack.push(output.length);
                    } else if (op === ':') {
                        // Pop operators until we find the matching ?
                        while (opStack.length && opStack[opStack.length - 1].value !== '?') {
                            output.push(opStack.pop().value);
                        }
                        // Keep the ? on stack, we'll resolve it when we have the false branch
                    }

                    const prec = precedence[op] || 0;
                    while (opStack.length) {
                        const top = opStack[opStack.length - 1];
                        if (top.type === '(' || top.type === 'func') break;
                        const topPrec = precedence[top.value] || 0;
                        if (topPrec < prec) break;
                        if (topPrec === prec && rightAssoc.has(op)) break;
                        output.push(opStack.pop().value);
                    }
                    opStack.push(tok);
                }
            }

            while (opStack.length) {
                const op = opStack.pop();
                if (op.type !== '(') {
                    // Handle ternary: convert ? and : to single ?: operator
                    if (op.value === '?' || op.value === ':') {
                        // Skip standalone ? and :, we'll handle ternary differently
                    } else {
                        output.push(op.value);
                    }
                }
            }

            // Post-process to handle ternary operators
            // Simple approach: find patterns and convert
            return postProcessTernary(output, expr);
        }

        // Simpler approach: evaluate expression using a recursive descent parser
        function parseExpr(expr) {
            const tokens = tokenize(expr);
            let pos = 0;

            function peek() { return tokens[pos]; }
            function consume() { return tokens[pos++]; }

            function parseComma() {
                // Comma operator has lowest precedence
                let left = parseAssignment();
                while (peek() && peek().type === ',') {
                    consume(); // ,
                    const right = parseAssignment();
                    // Generate RPN: left right ','
                    // The ',' operator will pop both and return right
                    left = [...left, ...right, ','];
                }
                return left;
            }

            function parseAssignment() {
                // Check for variable assignment: var = expr
                if (peek() && peek().type === 'var') {
                    const varName = peek().value;
                    const nextPos = pos + 1;
                    if (tokens[nextPos] && tokens[nextPos].type === '=') {
                        consume(); // var
                        consume(); // =
                        const value = parseAssignment();
                        // Generate RPN: value varName '='
                        return [...value, varName, '='];
                    }
                }
                return parseTernary();
            }

            function parseTernary() {
                let left = parseOr();
                if (peek() && peek().value === '?') {
                    consume(); // ?
                    const mid = parseTernary();
                    if (peek() && peek().value === ':') {
                        consume(); // :
                        const right = parseTernary();
                        return [...left, ...mid, ...right, '?:'];
                    }
                }
                return left;
            }

            function parseOr() {
                let left = parseXor();
                while (peek() && peek().value === '|') {
                    consume();
                    const right = parseXor();
                    left = [...left, ...right, '|'];
                }
                return left;
            }

            function parseXor() {
                let left = parseAnd();
                while (peek() && peek().value === '^') {
                    consume();
                    const right = parseAnd();
                    left = [...left, ...right, '^'];
                }
                return left;
            }

            function parseAnd() {
                let left = parseEquality();
                while (peek() && peek().value === '&') {
                    consume();
                    const right = parseEquality();
                    left = [...left, ...right, '&'];
                }
                return left;
            }

            function parseEquality() {
                let left = parseComparison();
                while (peek() && (peek().value === '==' || peek().value === '!=')) {
                    const op = consume().value;
                    const right = parseComparison();
                    left = [...left, ...right, op];
                }
                return left;
            }

            function parseComparison() {
                let left = parseShift();
                while (peek() && ['<', '>', '<=', '>='].includes(peek().value)) {
                    const op = consume().value;
                    const right = parseShift();
                    left = [...left, ...right, op];
                }
                return left;
            }

            function parseShift() {
                let left = parseAddSub();
                while (peek() && (peek().value === '<<' || peek().value === '>>')) {
                    const op = consume().value;
                    const right = parseAddSub();
                    left = [...left, ...right, op];
                }
                return left;
            }

            function parseAddSub() {
                let left = parseMulDiv();
                while (peek() && (peek().value === '+' || peek().value === '-')) {
                    const op = consume().value;
                    const right = parseMulDiv();
                    left = [...left, ...right, op];
                }
                return left;
            }

            function parseMulDiv() {
                let left = parseUnary();
                while (peek() && ['*', '/', '%'].includes(peek().value)) {
                    const op = consume().value;
                    const right = parseUnary();
                    left = [...left, ...right, op];
                }
                return left;
            }

            function parseUnary() {
                if (peek() && peek().value === '~') {
                    consume();
                    const right = parseUnary();
                    return [...right, '~'];
                }
                if (peek() && peek().value === '-') {
                    consume();
                    const right = parseUnary();
                    return [{v: 0, i: true}, ...right, '-'];
                }
                return parsePrimary();
            }

            function parsePrimary() {
                const tok = peek();
                if (!tok) return [{v: 0, i: true}];

                if (tok.type === 'num') {
                    consume();
                    return [{v: tok.value, i: tok.isInt}];
                }

                if (tok.type === 't') {
                    consume();
                    return ['t'];
                }

                if (tok.type === 'var') {
                    const varName = consume().value;
                    // Variable reference - push variable name with 'VAR:' prefix
                    return ['VAR:' + varName];
                }

                if (tok.type === 'func') {
                    const fn = consume().value;
                    if (peek() && peek().type === '(') {
                        consume(); // (
                        const args = [];
                        if (peek() && peek().type !== ')') {
                            args.push(parseTernary());
                            while (peek() && peek().type === ',') {
                                consume();
                                args.push(parseTernary());
                            }
                        }
                        if (peek() && peek().type === ')') consume();
                        // Flatten args and add function
                        const flat = args.flat();
                        return [...flat, fn];
                    }
                    return [fn];
                }

                if (tok.type === '(') {
                    consume();
                    const inner = parseTernary();
                    if (peek() && peek().type === ')') consume();
                    return inner;
                }

                consume();
                return [{v: 0, i: true}];
            }

            try {
                return parseComma();
            } catch (e) {
                return [{v: 0, i: true}];
            }
        }

        function postProcessTernary(rpn, expr) {
            // Use the recursive descent parser instead
            return parseExpr(expr);
        }

        // Initialize audio
        async function initAudio() {
            if (audioCtx) return;

            audioCtx = new AudioContext({ sampleRate: currentSampleRate });

            const blob = new Blob([workletCode], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);

            await audioCtx.audioWorklet.addModule(url);
            workletNode = new AudioWorkletNode(audioCtx, 'bytebeat-processor');
            gainNode = audioCtx.createGain();
            gainNode.gain.value = volume;
            workletNode.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            URL.revokeObjectURL(url);
        }

        // Send expression to worklet based on current mode
        function sendExpression(keepTime) {
            if (!workletNode) return;
            if (currentMode === 'C') {
                const rpn = parseExpr(expression);
                workletNode.port.postMessage({ type: 'setRPN', rpn, mode: 'C', keepTime: !!keepTime });
            } else {
                workletNode.port.postMessage({ type: 'setJS', expr: expression, mode: currentMode, keepTime: !!keepTime });
            }
        }

        // Start audio
        async function startAudio() {
            await initAudio();

            // Recreate context if sample rate changed
            if (audioCtx.sampleRate !== currentSampleRate) {
                audioCtx.close();
                audioCtx = null;
                workletNode = null;
                gainNode = null;
                await initAudio();
            }

            sendExpression(false);
            workletNode.port.postMessage({ type: 'play' });

            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
        }

        // Stop audio
        function stopAudio() {
            if (workletNode) {
                workletNode.port.postMessage({ type: 'stop' });
            }
        }

        // Toggle play
        async function togglePlay() {
            if (isPlaying) {
                stopAudio();
                isPlaying = false;
                if (playBtnEl) { playBtnEl.querySelector('.key-main').textContent = 'â–¸'; playBtnEl.classList.remove('active'); }
            } else {
                await startAudio();
                isPlaying = true;
                if (playBtnEl) { playBtnEl.querySelector('.key-main').textContent = 'â– '; playBtnEl.classList.add('active'); }
            }
        }

        // Key repeat functions
        function startKeyRepeat(action) {
            stopKeyRepeat();
            currentRepeatAction = action;
            
            // Execute immediately
            action();
            
            // Start repeat after delay
            keyRepeatTimer = setTimeout(() => {
                keyRepeatInterval = setInterval(action, KEY_REPEAT_RATE);
            }, KEY_REPEAT_DELAY);
        }

        function stopKeyRepeat() {
            if (keyRepeatTimer) {
                clearTimeout(keyRepeatTimer);
                keyRepeatTimer = null;
            }
            if (keyRepeatInterval) {
                clearInterval(keyRepeatInterval);
                keyRepeatInterval = null;
            }
            currentRepeatAction = null;
        }

        // Modal state handlers
        function enterSrInput() {
            srInputMode = true;
            srInputBuffer = String(currentSampleRate);
            updateDisplay();
        }

        function confirmSrInput() {
            const sr = parseInt(srInputBuffer) || currentSampleRate;
            currentSampleRate = Math.max(100, Math.min(48000, sr));
            srInputMode = false;
            updateDisplay();
            if (isPlaying) { stopAudio(); startAudio(); }
        }

        function cancelModal() {
            srInputMode = false;
            modeSelectMode = false;
            updateDisplay();
        }

        function enterModeSelect() {
            modeSelectMode = true;
            updateDisplay();
        }

        function cycleModeSelect(dir) {
            const idx = modes.indexOf(currentMode);
            currentMode = modes[(idx + dir + modes.length) % modes.length];
            updateDisplay();
        }

        function confirmModeSelect() {
            modeSelectMode = false;
            updateDisplay();
            if (isPlaying) { stopAudio(); startAudio(); }
        }

        function adjustVolume(delta) {
            volume = Math.max(0, Math.min(1, Math.round((volume + delta) * 10) / 10));
            if (gainNode) gainNode.gain.value = volume;
            updateDisplay();
        }

        // Key map: 6 columns x 6 rows
        const keymap = [
            // Row 0
            {base:'(', shift:'MOD', shiftAction:'mod', abc:'a', abcShift:'A'},
            {base:')', shift:'SR', shiftAction:'sr', abc:'b', abcShift:'B'},
            {base:'[', shift:'V+', shiftAction:'vol-up', abc:'c', abcShift:'C'},
            {base:']', shift:'V-', shiftAction:'vol-down', abc:'d', abcShift:'D'},
            {action:'abc', label:'ABC', cls:'abc toggle'},
            {action:'del', label:'DEL', cls:'action'},
            // Row 1
            {base:'?', abc:'e', abcShift:'E'},
            {base:':', abc:'f', abcShift:'F'},
            {base:'!', abc:'g', abcShift:'G'},
            {base:'&', abc:'h', abcShift:'H'},
            {base:'|', abc:'i', abcShift:'I'},
            {base:'^', abc:'j', abcShift:'J'},
            // Row 2
            {base:'7', abc:'k', abcShift:'K'},
            {base:'8', abc:'l', abcShift:'L'},
            {base:'9', abc:'m', abcShift:'M'},
            {base:'<', shift:'{', abc:'n', abcShift:'N'},
            {base:'>', shift:'}', abc:'o', abcShift:'O'},
            {base:'=', shift:'#', abc:'p', abcShift:'P'},
            // Row 3
            {base:'4', abc:'q', abcShift:'Q'},
            {base:'5', abc:'r', abcShift:'R'},
            {base:'6', abc:'s', abcShift:'S'},
            {base:'+', shift:';', abc:'t', abcShift:'T'},
            {base:'-', shift:',', abc:'u', abcShift:'U'},
            {base:'%', shift:'$', abc:'v', abcShift:'V'},
            // Row 4
            {base:'1', abc:'w', abcShift:'W'},
            {base:'2', abc:'x', abcShift:'X'},
            {base:'3', abc:'y', abcShift:'Y'},
            {base:'*', shift:'@', abc:'z', abcShift:'Z'},
            {base:'/', shift:'\\', abcAction:'tab', abcLabel:'TAB', abcShift:null},
            {base:'~', shift:'$', abcAction:'enter', abcLabel:'\u21B5', abcShift:null},
            // Row 5
            {action:'shift', label:'\u2302', cls:'shift toggle'},
            {base:'0', abc:' ', abcLabel:'SP', abcShift:null},
            {base:'.', shift:'t', abc:'_', abcShift:null},
            {action:'left', label:'\u2190', cls:'nav'},
            {action:'right', label:'\u2192', cls:'nav'},
            {action:'play', label:'\u25B8', cls:'play'},
        ];

        function escapeHtml(s) {
            return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        }

        function getKeyChar(k) {
            if (k.action) return null;
            if (abcMode) {
                if (shiftActive) {
                    if ('abcShift' in k) return k.abcShift;
                    if (k.abcAction) return null;
                    return k.abc || k.base;
                }
                if (k.abcAction === 'tab') return '   ';
                if (k.abcAction === 'enter') return '\n';
                if (k.abc !== undefined) return k.abc;
                return k.base;
            }
            if (shiftActive) {
                if (k.shiftAction) return null;
                return k.shift || k.base;
            }
            return k.base;
        }

        function handleShiftAction(action) {
            switch (action) {
                case 'mod': enterModeSelect(); break;
                case 'sr': enterSrInput(); break;
                case 'vol-up': adjustVolume(0.1); break;
                case 'vol-down': adjustVolume(-0.1); break;
            }
        }

        function buildKeyboard() {
            const kb = document.getElementById('keyboard');
            kb.innerHTML = '';
            keymap.forEach(k => {
                const btn = document.createElement('button');
                btn.className = 'key' + (k.cls ? ' ' + k.cls : '');
                if (k.action) {
                    btn.innerHTML = '<span class="key-main">' + k.label + '</span>';
                } else {
                    const sh = k.shift ? escapeHtml(k.shift) : '';
                    const ab = k.abcLabel || (k.abc && k.abc.trim() ? k.abc : '') || '';
                    btn.innerHTML =
                        '<span class="key-hint shift">' + sh + '</span>' +
                        '<span class="key-main">' + escapeHtml(k.base) + '</span>' +
                        '<span class="key-hint abc">' + escapeHtml(ab) + '</span>';
                }
                if (k.action) {
                    setupActionKey(btn, k);
                } else {
                    setupCharKey(btn, k);
                }
                kb.appendChild(btn);
            });
        }

        function setupCharKey(btn, k) {
            const doPress = () => {
                // Handle shift actions (MOD, SR, V+, V-)
                if (shiftActive && k.shiftAction) {
                    handleShiftAction(k.shiftAction);
                    return;
                }
                // Handle modal states
                if (srInputMode) {
                    const ch = k.base;
                    if ('0123456789'.includes(ch)) {
                        srInputBuffer += ch;
                        updateDisplay();
                    }
                    return;
                }
                if (modeSelectMode) return;
                // Normal key press
                const ch = getKeyChar(k);
                if (ch != null) insertChar(ch);
            };
            btn.addEventListener('touchstart', e => { e.preventDefault(); startKeyRepeat(doPress); });
            btn.addEventListener('touchend', e => { e.preventDefault(); stopKeyRepeat(); });
            btn.addEventListener('touchcancel', e => { e.preventDefault(); stopKeyRepeat(); });
            btn.addEventListener('mousedown', e => { e.preventDefault(); startKeyRepeat(doPress); });
            btn.addEventListener('mouseup', e => { e.preventDefault(); stopKeyRepeat(); });
            btn.addEventListener('mouseleave', () => stopKeyRepeat());
        }

        function setupActionKey(btn, k) {
            const repeatables = ['del', 'left', 'right'];
            const doAction = () => {
                // Handle modal states
                if (srInputMode) {
                    if (k.action === 'del') { srInputBuffer = srInputBuffer.slice(0, -1); updateDisplay(); }
                    else if (k.action === 'play') { confirmSrInput(); }
                    return;
                }
                if (modeSelectMode) {
                    if (k.action === 'left') { cycleModeSelect(-1); }
                    else if (k.action === 'right') { cycleModeSelect(1); }
                    else if (k.action === 'play') { confirmModeSelect(); }
                    return;
                }
                // Normal actions
                switch (k.action) {
                    case 'del': deleteChar(); break;
                    case 'left': moveCursor(-1); break;
                    case 'right': moveCursor(1); break;
                    case 'play': togglePlay(); break;
                    case 'abc': toggleAbc(); break;
                }
            };
            if (k.action === 'shift') {
                const activate = () => { shiftActive = true; btn.classList.add('active'); };
                const deactivate = () => { shiftActive = false; shiftLocked = false; btn.classList.remove('active'); };
                const onDown = () => {
                    if (shiftLocked) { deactivate(); return; }
                    activate();
                    shiftLongPressTimer = setTimeout(() => { shiftLocked = true; shiftLongPressTimer = null; }, SHIFT_LONG_PRESS_MS);
                };
                const onUp = () => {
                    if (shiftLongPressTimer) { clearTimeout(shiftLongPressTimer); shiftLongPressTimer = null; }
                    if (!shiftLocked) deactivate();
                };
                btn.addEventListener('touchstart', e => { e.preventDefault(); onDown(); });
                btn.addEventListener('touchend', e => { e.preventDefault(); onUp(); });
                btn.addEventListener('touchcancel', e => { e.preventDefault(); onUp(); });
                btn.addEventListener('mousedown', e => { e.preventDefault(); onDown(); });
                btn.addEventListener('mouseup', e => { e.preventDefault(); onUp(); });
                btn.addEventListener('mouseleave', () => { if (!shiftLocked) onUp(); });
            } else if (repeatables.includes(k.action)) {
                btn.addEventListener('touchstart', e => { e.preventDefault(); startKeyRepeat(doAction); });
                btn.addEventListener('touchend', e => { e.preventDefault(); stopKeyRepeat(); });
                btn.addEventListener('touchcancel', e => { e.preventDefault(); stopKeyRepeat(); });
                btn.addEventListener('mousedown', e => { e.preventDefault(); startKeyRepeat(doAction); });
                btn.addEventListener('mouseup', e => { e.preventDefault(); stopKeyRepeat(); });
                btn.addEventListener('mouseleave', () => stopKeyRepeat());
            } else {
                btn.addEventListener('click', doAction);
            }
            if (k.action === 'abc') abcBtnEl = btn;
            if (k.action === 'play') playBtnEl = btn;
        }

        function toggleAbc() {
            abcMode = !abcMode;
            if (abcBtnEl) abcBtnEl.classList.toggle('active', abcMode);
            modeDisplay.textContent = abcMode ? 'ABC' : '';
        }

        // Keyboard support for desktop
        let physicalKeyRepeat = new Map(); // Track which keys are being held
        
        document.addEventListener('keydown', async (e) => {
            // Handle key repeat for physical keyboard
            const keyId = e.key + (e.ctrlKey ? '_ctrl' : '') + (e.metaKey ? '_meta' : '');
            
            if (e.key === 'Backspace') {
                e.preventDefault();
                if (!physicalKeyRepeat.has(keyId)) {
                    physicalKeyRepeat.set(keyId, true);
                    startKeyRepeat(deleteChar);
                }
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                if (!physicalKeyRepeat.has(keyId)) {
                    physicalKeyRepeat.set(keyId, true);
                    startKeyRepeat(() => moveCursor(-1));
                }
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                if (!physicalKeyRepeat.has(keyId)) {
                    physicalKeyRepeat.set(keyId, true);
                    startKeyRepeat(() => moveCursor(1));
                }
            } else if (e.key === 'Enter') {
                if (!e.repeat) {
                    togglePlay();
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                // Copy expression
                e.preventDefault();
                if (!e.repeat) {
                    navigator.clipboard.writeText(expression);
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                // Paste at cursor
                e.preventDefault();
                if (!e.repeat) {
                    const text = await navigator.clipboard.readText();
                    insertChar(text);
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'x') {
                // Cut expression
                e.preventDefault();
                if (!e.repeat) {
                    navigator.clipboard.writeText(expression);
                    saveState();
                    expression = '';
                    cursorPos = 0;
                    updateDisplay();
                    liveUpdate();
                    saveExpression();
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                // Undo
                e.preventDefault();
                if (!e.repeat) {
                    undo();
                }
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) {
                // Redo
                e.preventDefault();
                if (!e.repeat) {
                    redo();
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                // Select all - move cursor to end
                e.preventDefault();
                if (!e.repeat) {
                    cursorPos = expression.length;
                    updateDisplay();
                }
            } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                if (!physicalKeyRepeat.has(keyId)) {
                    physicalKeyRepeat.set(keyId, true);
                    startKeyRepeat(() => insertChar(e.key));
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const keyId = e.key + (e.ctrlKey ? '_ctrl' : '') + (e.metaKey ? '_meta' : '');
            if (physicalKeyRepeat.has(keyId)) {
                physicalKeyRepeat.delete(keyId);
                stopKeyRepeat();
            }
        });

        // Toolbar button handlers
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        copyBtn.addEventListener('click', () => navigator.clipboard.writeText(expression));
        pasteBtn.addEventListener('click', async () => {
            const text = await navigator.clipboard.readText();
            insertChar(text);
        });
        libraryBtn.addEventListener('click', openLibrary);
        saveBtn.addEventListener('click', saveCurrentSong);

        // Library modal handlers
        modalClose.addEventListener('click', closeLibrary);
        libraryModal.addEventListener('click', (e) => {
            if (e.target === libraryModal) {
                closeLibrary();
            }
        });
        tabPresets.addEventListener('click', () => switchLibraryTab('presets'));
        tabSaved.addEventListener('click', () => switchLibraryTab('saved'));

        // Build keyboard and initial display
        buildKeyboard();
        updateDisplay();
    </script>
</body>
</html>
