<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bytebeat C Mobile</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
            max-width: 500px;
            margin: 0 auto;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            gap: 4px;
            padding: 5px 10px;
            background: #222;
            border-bottom: 1px solid #333;
        }

        .toolbar button {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 12px;
            color: #e0e0e0;
            cursor: pointer;
        }

        .toolbar button:active {
            background: #444;
        }

        .toolbar button:disabled {
            opacity: 0.4;
            cursor: default;
        }

        .toolbar .spacer {
            flex: 1;
        }

        /* Expression Panel */
        .expression-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
            min-height: 80px;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }

        .expression-display {
            flex: 1;
            background: #0d0d0d;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 18px;
            overflow-y: auto;
            overflow-x: hidden;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.4;
        }

        .expression-display .cursor {
            animation: blink-cursor 1s infinite;
        }

        .expression-display .cursor-end {
            animation: blink-end 1s infinite;
        }

        @keyframes blink-cursor {
            0%, 50% { background: #e0e0e0; color: #0d0d0d; }
            51%, 100% { background: transparent; color: #e0e0e0; }
        }

        @keyframes blink-end {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Keyboard Panel */
        .keyboard-panel {
            padding: 5px;
        }

        .keyboard {
            display: grid;
            grid-template-columns: repeat(14, 1fr);
            border: 1px solid #444;
        }

        .keyboard .key {
            border: none;
            box-shadow: inset 2px 2px 0px 0px #ffffff12, inset -2px -2px 0px 0px #000000d9; 
        }

        #main-keys, #fn-keys {
            display: contents;
        }

        #fn-keys { display: none; }
        #fn-keys.active { display: contents; }

        .row-hex { display: none; }
        .row-hex.active { display: contents; }

        .key { grid-column: span 2; }
        .key.wide { grid-column: span 4; }
        .key.w3 { grid-column: span 3; }
        .key.fn-w4 { grid-column: span 4; }
        .key.fn-w3 { grid-column: span 3; }

        .key {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 0;
            padding: 12px 4px;
            font-size: 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            color: #e0e0e0;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 44px;
        }

        .key:active {
            background: #444;
            border-color: #666;
        }

        .key.modifier {
            background: #1e3a5f;
            border-color: #2a5080;
        }

        .key.modifier:active {
            background: #2a5080;
        }

        .key.modifier.active {
            background: #3a6090;
            border-color: #4a80b0;
        }

        .key.action {
            background: #3a1e1e;
            border-color: #5a2a2a;
        }

        .key.action:active {
            background: #5a2a2a;
        }

        .key.play {
            background: #1e3a1e;
            border-color: #2a5a2a;
        }

        .key.play:active, .key.play.active {
            background: #2a5a2a;
            border-color: #3a7a3a;
        }

        .key.live {
            background: #3a2a1e;
            border-color: #5a3a2a;
        }

        .key.live:active, .key.live.active {
            background: #5a4a2a;
            border-color: #7a6a3a;
        }

        .key.nav {
            background: #2a2a3a;
            border-color: #3a3a5a;
        }

        .key.nav:active {
            background: #3a3a5a;
        }

            </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <button id="undo-btn" disabled>Undo</button>
            <button id="redo-btn" disabled>Redo</button>
            <span class="spacer"></span>
            <button id="copy-btn">Copy</button>
            <button id="paste-btn">Paste</button>
        </div>
        <div class="expression-panel">
            <div class="status-bar">
                <span id="sr-display">SR: 8000</span>
                <span id="mode-display"></span>
            </div>
            <div class="expression-display" id="expr-display"><span id="expr-before"></span><span id="expr-cursor"></span><span id="expr-after"></span></div>
        </div>

        <div class="keyboard-panel">
            <div class="keyboard">
                <button class="key modifier" data-action="bin">0b</button>
                <button class="key modifier" data-action="hex-prefix">0x</button>
                <button class="key modifier" data-action="sr">SR</button>
                <button class="key modifier" data-action="hex" id="hex-btn">HEX</button>
                <button class="key modifier" data-action="fn" id="fn-btn">FN</button>
                <button class="key action wide" data-action="del">DEL</button>

                <div id="main-keys">
                    <div class="row-hex" id="row-hex">
                        <button class="key" data-char="a">a</button>
                        <button class="key" data-char="b">b</button>
                        <button class="key w3" data-char="c">c</button>
                        <button class="key w3" data-char="d">d</button>
                        <button class="key" data-char="e">e</button>
                        <button class="key" data-char="f">f</button>
                    </div>
                    <button class="key" data-char="7">7</button>
                    <button class="key" data-char="8">8</button>
                    <button class="key" data-char="9">9</button>
                    <button class="key" data-char="-">-</button>
                    <button class="key" data-char="+">+</button>
                    <button class="key" data-char="%">%</button>
                    <button class="key" data-char="~">~</button>

                    <button class="key" data-char="4">4</button>
                    <button class="key" data-char="5">5</button>
                    <button class="key" data-char="6">6</button>
                    <button class="key" data-char="*">*</button>
                    <button class="key" data-char="/">/</button>
                    <button class="key" data-char="^">^</button>
                    <button class="key" data-char=",">,</button>

                    <button class="key" data-char="1">1</button>
                    <button class="key" data-char="2">2</button>
                    <button class="key" data-char="3">3</button>
                    <button class="key" data-char="&">&</button>
                    <button class="key" data-char="|">|</button>
                    <button class="key" data-char="?">?</button>
                    <button class="key" data-char=":">:</button>

                    <button class="key" data-char="t">t</button>
                    <button class="key" data-char="0">0</button>
                    <button class="key" data-char=".">.</button>
                    <button class="key" data-char="(">(</button>
                    <button class="key" data-char=")">)</button>
                    <button class="key" data-char="<">&lt;</button>
                    <button class="key" data-char=">">&gt;</button>
                </div>

                <div id="fn-keys">
                    <!-- Trig -->
                    <button class="key" data-char="sin(">sin</button>
                    <button class="key" data-char="cos(">cos</button>
                    <button class="key" data-char="tan(">tan</button>
                    <button class="key" data-char="asin(">asin</button>
                    <button class="key" data-char="acos(">acos</button>
                    <button class="key" data-char="atan(">atan</button>
                    <button class="key" data-char="PI">PI</button>
                    <!-- Hyperbolic -->
                    <button class="key" data-char="sinh(">sinh</button>
                    <button class="key" data-char="cosh(">cosh</button>
                    <button class="key" data-char="tanh(">tanh</button>
                    <button class="key" data-char="sqrt(">sqrt</button>
                    <button class="key" data-char="cbrt(">cbrt</button>
                    <button class="key" data-char="pow(">pow</button>
                    <button class="key" data-char="E">E</button>
                    <!-- Logs & exp -->
                    <button class="key" data-char="log(">log</button>
                    <button class="key" data-char="log10(">lg10</button>
                    <button class="key" data-char="exp(">exp</button>
                    <button class="key" data-char="fabs(">fabs</button>
                    <button class="key" data-char="fmod(">fmod</button>
                    <button class="key" data-char="modf(">modf</button>
                    <button class="key" data-char="(">(</button>
                    <!-- Rounding -->
                    <button class="key" data-char="floor(">flr</button>
                    <button class="key" data-char="ceil(">ceil</button>
                    <button class="key" data-char="round(">rnd</button>
                    <button class="key" data-char="int(">int</button>
                    <button class="key" data-char="min(">min</button>
                    <button class="key" data-char="max(">max</button>
                    <button class="key" data-char=")">)</button>
                </div>

                <button class="key nav wide" data-action="left">Left</button>
                <button class="key play wide" data-action="play" id="play-btn">Play</button>
                <button class="key live" data-action="live" id="live-btn">Live</button>
                <button class="key nav wide" data-action="right">Right</button>
            </div>
        </div>
    </div>

    <script>
        // Worklet code as string
        const workletCode = `
class BytebeatProcessor extends AudioWorkletProcessor {
    constructor() {
        super();
        this.t = 0;
        this.rpn = [];
        this.playing = false;
        this.port.onmessage = (e) => {
            if (e.data.type === 'setRPN') {
                this.rpn = e.data.rpn;
                if (!e.data.keepTime) this.t = 0;
            } else if (e.data.type === 'play') {
                this.playing = true;
            } else if (e.data.type === 'stop') {
                this.playing = false;
            } else if (e.data.type === 'reset') {
                this.t = 0;
            }
        };
    }

    // Typed value helpers: {v: value, i: isInteger}
    I(n) { return {v: Math.trunc(n), i: true}; }
    F(n) { return {v: n, i: false}; }
    pop(stack) { const x = stack.pop(); return x || {v: 0, i: true}; }
    val(x) { return x.v; }

    evalRPN(t) {
        if (this.rpn.length === 0) return 0;
        const stack = [];
        const vars = {}; // Variables reset on each sample
        
        for (let i = 0; i < this.rpn.length; i++) {
            const token = this.rpn[i];
            
            // Typed number from parser: {v, i}
            if (typeof token === 'object' && 'v' in token) {
                stack.push(token);
            } else if (token === 't') {
                stack.push(this.I(t));
            } else if (typeof token === 'string' && token.startsWith('VAR:')) {
                // Variable reference
                const varName = token.substring(4);
                const value = vars[varName];
                stack.push(value || this.I(0));
            } else if (typeof token === 'string' && token !== '=' && i + 1 < this.rpn.length && this.rpn[i + 1] === '=') {
                // This is a variable name followed by '=' - skip it, will be handled by '=' case
                continue;
            } else if (typeof token === 'string' && token === '=') {
                // Variable assignment: previous token is variable name, pop value from stack
                const varName = this.rpn[i - 1];
                const value = this.pop(stack);
                vars[varName] = value;
                stack.push(value);
            } else {
                let a, b, c, av, bv, cv, bothInt;
                switch (token) {
                    // Arithmetic - type depends on operands
                    case '+':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        stack.push(bothInt ? this.I(a.v + b.v) : this.F(a.v + b.v));
                        break;
                    case '-':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        stack.push(bothInt ? this.I(a.v - b.v) : this.F(a.v - b.v));
                        break;
                    case '*':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        stack.push(bothInt ? this.I(a.v * b.v) : this.F(a.v * b.v));
                        break;
                    case '/':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        if (b.v === 0) { stack.push(this.I(0)); }
                        else if (bothInt) { stack.push(this.I(Math.trunc(a.v / b.v))); }
                        else { stack.push(this.F(a.v / b.v)); }
                        break;
                    case '%':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        if (b.v === 0) { stack.push(this.I(0)); }
                        else if (bothInt) { stack.push(this.I(a.v % b.v)); }
                        else { stack.push(this.F(a.v - Math.trunc(a.v / b.v) * b.v)); }
                        break;
                    // Bitwise - always integer
                    case '&': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v & b.v)); break;
                    case '|': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v | b.v)); break;
                    case '^': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v ^ b.v)); break;
                    case '~': a = this.pop(stack); stack.push(this.I(~a.v)); break;
                    case '<<': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v << b.v)); break;
                    case '>>': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v >> b.v)); break;
                    // Comparison - always integer (0 or 1)
                    case '<': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v < b.v ? 1 : 0)); break;
                    case '>': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v > b.v ? 1 : 0)); break;
                    case '<=': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v <= b.v ? 1 : 0)); break;
                    case '>=': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v >= b.v ? 1 : 0)); break;
                    case '==': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v === b.v ? 1 : 0)); break;
                    case '!=': b = this.pop(stack); a = this.pop(stack); stack.push(this.I(a.v !== b.v ? 1 : 0)); break;
                    // Ternary - preserves type of selected branch
                    case '?:':
                        c = this.pop(stack); b = this.pop(stack); a = this.pop(stack);
                        stack.push(a.v ? b : c);
                        break;
                    // Trig - always float
                    case 'sin': a = this.pop(stack); stack.push(this.F(Math.sin(a.v))); break;
                    case 'cos': a = this.pop(stack); stack.push(this.F(Math.cos(a.v))); break;
                    case 'tan': a = this.pop(stack); stack.push(this.F(Math.tan(a.v))); break;
                    case 'asin': a = this.pop(stack); stack.push(this.F(Math.asin(a.v))); break;
                    case 'acos': a = this.pop(stack); stack.push(this.F(Math.acos(a.v))); break;
                    case 'atan': a = this.pop(stack); stack.push(this.F(Math.atan(a.v))); break;
                    // Hyperbolic - always float
                    case 'sinh': a = this.pop(stack); stack.push(this.F(Math.sinh(a.v))); break;
                    case 'cosh': a = this.pop(stack); stack.push(this.F(Math.cosh(a.v))); break;
                    case 'tanh': a = this.pop(stack); stack.push(this.F(Math.tanh(a.v))); break;
                    // Roots & powers - always float
                    case 'sqrt': a = this.pop(stack); stack.push(this.F(Math.sqrt(a.v))); break;
                    case 'cbrt': a = this.pop(stack); stack.push(this.F(Math.cbrt(a.v))); break;
                    case 'pow': b = this.pop(stack); a = this.pop(stack); stack.push(this.F(Math.pow(a.v, b.v))); break;
                    case 'exp': a = this.pop(stack); stack.push(this.F(Math.exp(a.v))); break;
                    // Logs - always float
                    case 'log': a = this.pop(stack); stack.push(this.F(Math.log(a.v))); break;
                    case 'log10': a = this.pop(stack); stack.push(this.F(Math.log10(a.v))); break;
                    // Rounding - returns integer
                    case 'floor': a = this.pop(stack); stack.push(this.I(Math.floor(a.v))); break;
                    case 'ceil': a = this.pop(stack); stack.push(this.I(Math.ceil(a.v))); break;
                    case 'round': a = this.pop(stack); stack.push(this.I(Math.round(a.v))); break;
                    // Type conversion
                    case 'int': a = this.pop(stack); stack.push(this.I(a.v)); break;
                    case 'float': a = this.pop(stack); stack.push(this.F(a.v)); break;
                    // Misc - abs preserves type, fabs returns float
                    case 'abs': a = this.pop(stack); stack.push(a.i ? this.I(Math.abs(a.v)) : this.F(Math.abs(a.v))); break;
                    case 'fabs': a = this.pop(stack); stack.push(this.F(Math.abs(a.v))); break;
                    case 'min':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        stack.push(bothInt ? this.I(Math.min(a.v, b.v)) : this.F(Math.min(a.v, b.v)));
                        break;
                    case 'max':
                        b = this.pop(stack); a = this.pop(stack);
                        bothInt = a.i && b.i;
                        stack.push(bothInt ? this.I(Math.max(a.v, b.v)) : this.F(Math.max(a.v, b.v)));
                        break;
                    case 'fmod':
                        b = this.pop(stack); a = this.pop(stack);
                        stack.push(this.F(b.v !== 0 ? a.v - Math.trunc(a.v / b.v) * b.v : 0));
                        break;
                    case 'modf': a = this.pop(stack); stack.push(this.F(a.v - Math.trunc(a.v))); break;
                    // Constants - float
                    case 'PI': stack.push(this.F(Math.PI)); break;
                    case 'E': stack.push(this.F(Math.E)); break;
                    // Comma operator - pop left and right, return right
                    case ',':
                        b = this.pop(stack); // right operand
                        a = this.pop(stack); // left operand (discarded)
                        stack.push(b);
                        break;
                    default:
                        break;
                }
            }
        }
        const result = this.pop(stack);
        return result.v & 255;
    }

    process(inputs, outputs) {
        const output = outputs[0];
        if (!this.playing || output.length === 0) {
            return true;
        }
        const channel = output[0];
        for (let i = 0; i < channel.length; i++) {
            const sample = this.evalRPN(this.t);
            channel[i] = (sample - 128) / 128;
            this.t++;
        }
        return true;
    }
}

registerProcessor('bytebeat-processor', BytebeatProcessor);
`;

        // State - load expression from localStorage
        let expression = localStorage.getItem('bytebeat-expr') || '';
        let cursorPos = expression.length;
        let undoStack = [];
        let redoStack = [];
        let sampleRates = [8000, 11025, 16000, 22050, 32000, 44100, 48000];
        let srIndex = 0;
        let hexMode = false;
        let fnMode = false;
        let isPlaying = false;
        let liveMode = false;
        let audioCtx = null;
        let workletNode = null;

        // Key repeat state
        let keyRepeatTimer = null;
        let keyRepeatInterval = null;
        let currentRepeatAction = null;
        const KEY_REPEAT_DELAY = 500; // ms before repeat starts
        const KEY_REPEAT_RATE = 50;   // ms between repeats

        // DOM elements
        const exprBefore = document.getElementById('expr-before');
        const exprCursor = document.getElementById('expr-cursor');
        const exprAfter = document.getElementById('expr-after');
        const srDisplay = document.getElementById('sr-display');
        const modeDisplay = document.getElementById('mode-display');
        const hexBtn = document.getElementById('hex-btn');
        const fnBtn = document.getElementById('fn-btn');
        const playBtn = document.getElementById('play-btn');
        const liveBtn = document.getElementById('live-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const copyBtn = document.getElementById('copy-btn');
        const pasteBtn = document.getElementById('paste-btn');

        // Save expression to localStorage
        function saveExpression() {
            localStorage.setItem('bytebeat-expr', expression);
        }

        // Save state for undo
        function saveState() {
            undoStack.push({ expression, cursorPos });
            redoStack = [];
            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length > 0) {
                redoStack.push({ expression, cursorPos });
                const state = undoStack.pop();
                expression = state.expression;
                cursorPos = state.cursorPos;
                updateDisplay();
                updateUndoRedoButtons();
                liveUpdate();
                saveExpression();
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                undoStack.push({ expression, cursorPos });
                const state = redoStack.pop();
                expression = state.expression;
                cursorPos = state.cursorPos;
                updateDisplay();
                updateUndoRedoButtons();
                liveUpdate();
                saveExpression();
            }
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
        }

        // Update display
        function updateDisplay() {
            exprBefore.textContent = expression.slice(0, cursorPos);
            if (cursorPos >= expression.length) {
                // Cursor at end - show underscore
                exprCursor.textContent = '_';
                exprCursor.className = 'cursor-end';
                exprAfter.textContent = '';
            } else {
                // Cursor inside - show inverted character
                exprCursor.textContent = expression[cursorPos];
                exprCursor.className = 'cursor';
                exprAfter.textContent = expression.slice(cursorPos + 1);
            }
            srDisplay.textContent = `SR: ${sampleRates[srIndex]}`;
            modeDisplay.textContent = hexMode ? 'HEX' : '';
        }

        // Live update - send new RPN to worklet without resetting t
        function liveUpdate() {
            if (liveMode && isPlaying && workletNode) {
                const rpn = parseExpr(expression);
                workletNode.port.postMessage({ type: 'setRPN', rpn, keepTime: true });
            }
        }

        // Insert character at cursor
        function insertChar(char) {
            saveState();
            expression = expression.slice(0, cursorPos) + char + expression.slice(cursorPos);
            cursorPos += char.length;
            updateDisplay();
            liveUpdate();
            saveExpression();
        }

        // Delete character before cursor
        function deleteChar() {
            if (cursorPos > 0) {
                saveState();
                expression = expression.slice(0, cursorPos - 1) + expression.slice(cursorPos);
                cursorPos--;
                updateDisplay();
                liveUpdate();
                saveExpression();
            }
        }

        // Move cursor
        function moveCursor(dir) {
            cursorPos = Math.max(0, Math.min(expression.length, cursorPos + dir));
            updateDisplay();
        }

        // Toggle hex mode
        function toggleHex() {
            // Turn off FN mode if active
            if (fnMode) {
                fnMode = false;
                fnBtn.classList.remove('active');
                document.getElementById('main-keys').style.display = '';
                document.getElementById('fn-keys').classList.remove('active');
            }
            hexMode = !hexMode;
            hexBtn.classList.toggle('active', hexMode);
            document.getElementById('row-hex').classList.toggle('active', hexMode);
            updateDisplay();
        }

        // Toggle FN mode
        function toggleFn() {
            // Turn off HEX mode if active
            if (hexMode) {
                hexMode = false;
                hexBtn.classList.remove('active');
                document.getElementById('row-hex').classList.remove('active');
                updateDisplay();
            }
            fnMode = !fnMode;
            fnBtn.classList.toggle('active', fnMode);
            document.getElementById('main-keys').style.display = fnMode ? 'none' : '';
            document.getElementById('fn-keys').classList.toggle('active', fnMode);
        }

        // Cycle sample rate
        function cycleSampleRate() {
            srIndex = (srIndex + 1) % sampleRates.length;
            updateDisplay();
            if (isPlaying) {
                stopAudio();
                startAudio();
            }
        }

        // C expression tokenizer
        function tokenize(expr) {
            const tokens = [];
            let i = 0;
            while (i < expr.length) {
                const c = expr[i];

                // Skip whitespace
                if (/\s/.test(c)) {
                    i++;
                    continue;
                }

                // Numbers (decimal, hex, binary) - track if integer or float
                if (/[0-9]/.test(c) || (c === '0' && (expr[i+1] === 'x' || expr[i+1] === 'b'))) {
                    let num = '';
                    let isInt = true;
                    if (c === '0' && expr[i+1] === 'x') {
                        // Hex - always integer
                        i += 2;
                        while (i < expr.length && /[0-9a-fA-F]/.test(expr[i])) {
                            num += expr[i++];
                        }
                        tokens.push({ type: 'num', value: parseInt(num, 16) || 0, isInt: true });
                    } else if (c === '0' && expr[i+1] === 'b') {
                        // Binary - always integer
                        i += 2;
                        while (i < expr.length && /[01]/.test(expr[i])) {
                            num += expr[i++];
                        }
                        tokens.push({ type: 'num', value: parseInt(num, 2) || 0, isInt: true });
                    } else {
                        // Decimal - integer unless contains '.'
                        while (i < expr.length && /[0-9.]/.test(expr[i])) {
                            if (expr[i] === '.') isInt = false;
                            num += expr[i++];
                        }
                        tokens.push({ type: 'num', value: parseFloat(num) || 0, isInt: isInt });
                    }
                    continue;
                }

                // Identifiers (t, variables, functions)
                if (/[a-zA-Z_]/.test(c)) {
                    let id = '';
                    while (i < expr.length && /[a-zA-Z_0-9]/.test(expr[i])) {
                        id += expr[i++];
                    }
                    if (id === 't') {
                        tokens.push({ type: 't' });
                    } else {
                        // Check if it's followed by '=' (variable assignment) or '(' (function)
                        let j = i;
                        while (j < expr.length && /\s/.test(expr[j])) j++;
                        if (j < expr.length && expr[j] === '=') {
                            tokens.push({ type: 'var', value: id });
                        } else if (j < expr.length && expr[j] === '(') {
                            tokens.push({ type: 'func', value: id });
                        } else {
                            // Variable reference
                            tokens.push({ type: 'var', value: id });
                        }
                    }
                    continue;
                }

                // Two-char operators
                const two = expr.slice(i, i+2);
                if (['<<', '>>', '<=', '>=', '==', '!='].includes(two)) {
                    tokens.push({ type: 'op', value: two });
                    i += 2;
                    continue;
                }

                // Single-char operators and parens
                if ('+-*/%&|^~<>?:(),='.includes(c)) {
                    if (c === '=') {
                        tokens.push({ type: '=', value: c });
                    } else {
                        tokens.push({ type: c === '(' || c === ')' ? c : (c === ',' ? ',' : 'op'), value: c });
                    }
                    i++;
                    continue;
                }

                // Unknown, skip
                i++;
            }
            return tokens;
        }

        // Shunting-yard algorithm for C expression to RPN
        function toRPN(expr) {
            const tokens = tokenize(expr);
            const output = [];
            const opStack = [];

            const precedence = {
                '?': 1, ':': 1,
                '|': 2,
                '^': 3,
                '&': 4,
                '==': 5, '!=': 5,
                '<': 6, '>': 6, '<=': 6, '>=': 6,
                '<<': 7, '>>': 7,
                '+': 8, '-': 8,
                '*': 9, '/': 9, '%': 9,
                '~': 10,
            };

            const rightAssoc = new Set(['?', ':']);

            let ternaryStack = []; // Track ternary operators

            for (let i = 0; i < tokens.length; i++) {
                const tok = tokens[i];

                if (tok.type === 'num') {
                    output.push(tok.value);
                } else if (tok.type === 't') {
                    output.push('t');
                } else if (tok.type === 'func') {
                    opStack.push(tok);
                } else if (tok.type === '(') {
                    opStack.push(tok);
                } else if (tok.type === ')') {
                    while (opStack.length && opStack[opStack.length - 1].type !== '(') {
                        const op = opStack.pop();
                        output.push(op.value);
                    }
                    if (opStack.length) opStack.pop(); // Remove '('
                    if (opStack.length && opStack[opStack.length - 1].type === 'func') {
                        output.push(opStack.pop().value);
                    }
                } else if (tok.type === ',') {
                    while (opStack.length && opStack[opStack.length - 1].type !== '(') {
                        output.push(opStack.pop().value);
                    }
                } else if (tok.type === 'op') {
                    const op = tok.value;

                    // Handle ternary operator
                    if (op === '?') {
                        ternaryStack.push(output.length);
                    } else if (op === ':') {
                        // Pop operators until we find the matching ?
                        while (opStack.length && opStack[opStack.length - 1].value !== '?') {
                            output.push(opStack.pop().value);
                        }
                        // Keep the ? on stack, we'll resolve it when we have the false branch
                    }

                    const prec = precedence[op] || 0;
                    while (opStack.length) {
                        const top = opStack[opStack.length - 1];
                        if (top.type === '(' || top.type === 'func') break;
                        const topPrec = precedence[top.value] || 0;
                        if (topPrec < prec) break;
                        if (topPrec === prec && rightAssoc.has(op)) break;
                        output.push(opStack.pop().value);
                    }
                    opStack.push(tok);
                }
            }

            while (opStack.length) {
                const op = opStack.pop();
                if (op.type !== '(') {
                    // Handle ternary: convert ? and : to single ?: operator
                    if (op.value === '?' || op.value === ':') {
                        // Skip standalone ? and :, we'll handle ternary differently
                    } else {
                        output.push(op.value);
                    }
                }
            }

            // Post-process to handle ternary operators
            // Simple approach: find patterns and convert
            return postProcessTernary(output, expr);
        }

        // Simpler approach: evaluate expression using a recursive descent parser
        function parseExpr(expr) {
            const tokens = tokenize(expr);
            let pos = 0;

            function peek() { return tokens[pos]; }
            function consume() { return tokens[pos++]; }

            function parseComma() {
                // Comma operator has lowest precedence
                let left = parseAssignment();
                while (peek() && peek().type === ',') {
                    consume(); // ,
                    const right = parseAssignment();
                    // Generate RPN: left right ','
                    // The ',' operator will pop both and return right
                    left = [...left, ...right, ','];
                }
                return left;
            }

            function parseAssignment() {
                // Check for variable assignment: var = expr
                if (peek() && peek().type === 'var') {
                    const varName = peek().value;
                    const nextPos = pos + 1;
                    if (tokens[nextPos] && tokens[nextPos].type === '=') {
                        consume(); // var
                        consume(); // =
                        const value = parseAssignment();
                        // Generate RPN: value varName '='
                        return [...value, varName, '='];
                    }
                }
                return parseTernary();
            }

            function parseTernary() {
                let left = parseOr();
                if (peek() && peek().value === '?') {
                    consume(); // ?
                    const mid = parseTernary();
                    if (peek() && peek().value === ':') {
                        consume(); // :
                        const right = parseTernary();
                        return [...left, ...mid, ...right, '?:'];
                    }
                }
                return left;
            }

            function parseOr() {
                let left = parseXor();
                while (peek() && peek().value === '|') {
                    consume();
                    const right = parseXor();
                    left = [...left, ...right, '|'];
                }
                return left;
            }

            function parseXor() {
                let left = parseAnd();
                while (peek() && peek().value === '^') {
                    consume();
                    const right = parseAnd();
                    left = [...left, ...right, '^'];
                }
                return left;
            }

            function parseAnd() {
                let left = parseEquality();
                while (peek() && peek().value === '&') {
                    consume();
                    const right = parseEquality();
                    left = [...left, ...right, '&'];
                }
                return left;
            }

            function parseEquality() {
                let left = parseComparison();
                while (peek() && (peek().value === '==' || peek().value === '!=')) {
                    const op = consume().value;
                    const right = parseComparison();
                    left = [...left, ...right, op];
                }
                return left;
            }

            function parseComparison() {
                let left = parseShift();
                while (peek() && ['<', '>', '<=', '>='].includes(peek().value)) {
                    const op = consume().value;
                    const right = parseShift();
                    left = [...left, ...right, op];
                }
                return left;
            }

            function parseShift() {
                let left = parseAddSub();
                while (peek() && (peek().value === '<<' || peek().value === '>>')) {
                    const op = consume().value;
                    const right = parseAddSub();
                    left = [...left, ...right, op];
                }
                return left;
            }

            function parseAddSub() {
                let left = parseMulDiv();
                while (peek() && (peek().value === '+' || peek().value === '-')) {
                    const op = consume().value;
                    const right = parseMulDiv();
                    left = [...left, ...right, op];
                }
                return left;
            }

            function parseMulDiv() {
                let left = parseUnary();
                while (peek() && ['*', '/', '%'].includes(peek().value)) {
                    const op = consume().value;
                    const right = parseUnary();
                    left = [...left, ...right, op];
                }
                return left;
            }

            function parseUnary() {
                if (peek() && peek().value === '~') {
                    consume();
                    const right = parseUnary();
                    return [...right, '~'];
                }
                if (peek() && peek().value === '-') {
                    consume();
                    const right = parseUnary();
                    return [{v: 0, i: true}, ...right, '-'];
                }
                return parsePrimary();
            }

            function parsePrimary() {
                const tok = peek();
                if (!tok) return [{v: 0, i: true}];

                if (tok.type === 'num') {
                    consume();
                    return [{v: tok.value, i: tok.isInt}];
                }

                if (tok.type === 't') {
                    consume();
                    return ['t'];
                }

                if (tok.type === 'var') {
                    const varName = consume().value;
                    // Variable reference - push variable name with 'VAR:' prefix
                    return ['VAR:' + varName];
                }

                if (tok.type === 'func') {
                    const fn = consume().value;
                    if (peek() && peek().type === '(') {
                        consume(); // (
                        const args = [];
                        if (peek() && peek().type !== ')') {
                            args.push(parseTernary());
                            while (peek() && peek().type === ',') {
                                consume();
                                args.push(parseTernary());
                            }
                        }
                        if (peek() && peek().type === ')') consume();
                        // Flatten args and add function
                        const flat = args.flat();
                        return [...flat, fn];
                    }
                    return [fn];
                }

                if (tok.type === '(') {
                    consume();
                    const inner = parseTernary();
                    if (peek() && peek().type === ')') consume();
                    return inner;
                }

                consume();
                return [{v: 0, i: true}];
            }

            try {
                return parseComma();
            } catch (e) {
                return [{v: 0, i: true}];
            }
        }

        function postProcessTernary(rpn, expr) {
            // Use the recursive descent parser instead
            return parseExpr(expr);
        }

        // Initialize audio
        async function initAudio() {
            if (audioCtx) return;

            audioCtx = new AudioContext({ sampleRate: sampleRates[srIndex] });

            const blob = new Blob([workletCode], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);

            await audioCtx.audioWorklet.addModule(url);
            workletNode = new AudioWorkletNode(audioCtx, 'bytebeat-processor');
            workletNode.connect(audioCtx.destination);

            URL.revokeObjectURL(url);
        }

        // Start audio
        async function startAudio() {
            await initAudio();

            // Recreate context if sample rate changed
            if (audioCtx.sampleRate !== sampleRates[srIndex]) {
                audioCtx.close();
                audioCtx = null;
                workletNode = null;
                await initAudio();
            }

            const rpn = parseExpr(expression);
            workletNode.port.postMessage({ type: 'setRPN', rpn });
            workletNode.port.postMessage({ type: 'play' });

            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
        }

        // Stop audio
        function stopAudio() {
            if (workletNode) {
                workletNode.port.postMessage({ type: 'stop' });
            }
        }

        // Toggle play
        async function togglePlay() {
            if (isPlaying) {
                stopAudio();
                isPlaying = false;
                playBtn.textContent = 'Play';
                playBtn.classList.remove('active');
            } else {
                await startAudio();
                isPlaying = true;
                playBtn.textContent = 'Stop';
                playBtn.classList.add('active');
            }
        }

        // Toggle live mode
        async function toggleLive() {
            liveMode = !liveMode;
            liveBtn.classList.toggle('active', liveMode);

            // When activating live mode, start playing with current expression
            if (liveMode && !isPlaying) {
                await startAudio();
                isPlaying = true;
                playBtn.textContent = 'Stop';
                playBtn.classList.add('active');
            }
        }

        // Key repeat functions
        function startKeyRepeat(action) {
            stopKeyRepeat();
            currentRepeatAction = action;
            
            // Execute immediately
            action();
            
            // Start repeat after delay
            keyRepeatTimer = setTimeout(() => {
                keyRepeatInterval = setInterval(action, KEY_REPEAT_RATE);
            }, KEY_REPEAT_DELAY);
        }

        function stopKeyRepeat() {
            if (keyRepeatTimer) {
                clearTimeout(keyRepeatTimer);
                keyRepeatTimer = null;
            }
            if (keyRepeatInterval) {
                clearInterval(keyRepeatInterval);
                keyRepeatInterval = null;
            }
            currentRepeatAction = null;
        }

        // Event handlers
        document.querySelectorAll('.key[data-char]').forEach(key => {
            const char = key.dataset.char;
            
            // Touch events for key repeat
            key.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startKeyRepeat(() => insertChar(char));
            });
            
            key.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopKeyRepeat();
            });
            
            key.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                stopKeyRepeat();
            });
            
            // Mouse events (for desktop)
            key.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startKeyRepeat(() => insertChar(char));
            });
            
            key.addEventListener('mouseup', (e) => {
                e.preventDefault();
                stopKeyRepeat();
            });
            
            key.addEventListener('mouseleave', () => {
                stopKeyRepeat();
            });
        });

        document.querySelectorAll('.key[data-action]').forEach(key => {
            const action = key.dataset.action;
            
            // Determine which actions should repeat
            const repeatableActions = ['del', 'left', 'right'];
            const shouldRepeat = repeatableActions.includes(action);
            
            const executeAction = () => {
                switch (action) {
                    case 'del': deleteChar(); break;
                    case 'left': moveCursor(-1); break;
                    case 'right': moveCursor(1); break;
                    case 'play': togglePlay(); break;
                    case 'live': toggleLive(); break;
                    case 'hex': toggleHex(); break;
                    case 'sr': cycleSampleRate(); break;
                    case 'fn': toggleFn(); break;
                    case 'bin': insertChar('0b'); break;
                    case 'hex-prefix': insertChar('0x'); break;
                }
            };
            
            if (shouldRepeat) {
                // Touch events for repeatable actions
                key.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startKeyRepeat(executeAction);
                });
                
                key.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    stopKeyRepeat();
                });
                
                key.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    stopKeyRepeat();
                });
                
                // Mouse events for repeatable actions
                key.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    startKeyRepeat(executeAction);
                });
                
                key.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    stopKeyRepeat();
                });
                
                key.addEventListener('mouseleave', () => {
                    stopKeyRepeat();
                });
            } else {
                // Non-repeatable actions use click
                key.addEventListener('click', executeAction);
            }
        });

        // Keyboard support for desktop
        let physicalKeyRepeat = new Map(); // Track which keys are being held
        
        document.addEventListener('keydown', async (e) => {
            // Handle key repeat for physical keyboard
            const keyId = e.key + (e.ctrlKey ? '_ctrl' : '') + (e.metaKey ? '_meta' : '');
            
            if (e.key === 'Backspace') {
                e.preventDefault();
                if (!physicalKeyRepeat.has(keyId)) {
                    physicalKeyRepeat.set(keyId, true);
                    startKeyRepeat(deleteChar);
                }
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                if (!physicalKeyRepeat.has(keyId)) {
                    physicalKeyRepeat.set(keyId, true);
                    startKeyRepeat(() => moveCursor(-1));
                }
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                if (!physicalKeyRepeat.has(keyId)) {
                    physicalKeyRepeat.set(keyId, true);
                    startKeyRepeat(() => moveCursor(1));
                }
            } else if (e.key === 'Enter') {
                if (!e.repeat) {
                    togglePlay();
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                // Copy expression
                e.preventDefault();
                if (!e.repeat) {
                    navigator.clipboard.writeText(expression);
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                // Paste at cursor
                e.preventDefault();
                if (!e.repeat) {
                    const text = await navigator.clipboard.readText();
                    insertChar(text);
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'x') {
                // Cut expression
                e.preventDefault();
                if (!e.repeat) {
                    navigator.clipboard.writeText(expression);
                    saveState();
                    expression = '';
                    cursorPos = 0;
                    updateDisplay();
                    liveUpdate();
                    saveExpression();
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                // Undo
                e.preventDefault();
                if (!e.repeat) {
                    undo();
                }
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) {
                // Redo
                e.preventDefault();
                if (!e.repeat) {
                    redo();
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                // Select all - move cursor to end
                e.preventDefault();
                if (!e.repeat) {
                    cursorPos = expression.length;
                    updateDisplay();
                }
            } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                if (!physicalKeyRepeat.has(keyId)) {
                    physicalKeyRepeat.set(keyId, true);
                    startKeyRepeat(() => insertChar(e.key));
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const keyId = e.key + (e.ctrlKey ? '_ctrl' : '') + (e.metaKey ? '_meta' : '');
            if (physicalKeyRepeat.has(keyId)) {
                physicalKeyRepeat.delete(keyId);
                stopKeyRepeat();
            }
        });

        // Toolbar button handlers
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        copyBtn.addEventListener('click', () => navigator.clipboard.writeText(expression));
        pasteBtn.addEventListener('click', async () => {
            const text = await navigator.clipboard.readText();
            insertChar(text);
        });

        // Initial display
        updateDisplay();
    </script>
</body>
</html>
